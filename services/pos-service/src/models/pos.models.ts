export interface SaleItem {
  lineItemId?: string; // Optional UUID for the line item itself
  itemId: string; // From inventory-service or local product catalog
  sku?: string;
  name: string; // Can be copied from item master or entered
  quantity: number;
  unitPrice: number; // Price before item-level discount/tax
  discountAmount?: number; // Item-level discount
  taxAmount?: number; // Item-level tax (can be complex depending on tax rules)
  lineTotal: number; // (quantity * unitPrice) - discountAmount + taxAmount
  notes?: string;
  // Add other fields like loyaltyPointsEarned, promotionsApplied (Array of promo IDs)
}

export type PaymentType = 'cash' | 'card_credit' | 'card_debit' | 'gift_card' | 'loyalty_points' | 'digital_wallet' | 'on_account' | 'other';
export interface PaymentDetail {
  id: string; // UUID for this payment attempt/record
  paymentType: PaymentType;
  amount: number; // Amount tendered for this specific payment type
  paymentGatewayTxnId?: string; // Transaction ID from payment gateway
  approvalCode?: string; // For card payments
  cardLast4Digits?: string;
  cardType?: string; // Visa, Mastercard, etc.
  giftCardId?: string;
  loyaltyPointsUsed?: number;
  referenceNumber?: string; // For external payment methods or notes
  status?: 'approved' | 'declined' | 'error' | 'pending'; // Status of this specific payment
  // other payment specific details
}

export type SaleStatus = 'in_progress' | 'parked' | 'completed' | 'voided' | 'partially_returned' | 'fully_returned';
export interface SaleTransaction {
  id: string; // UUID, generated by POS
  tenantId: string;
  registerId: string; // ID of the physical POS register or virtual terminal
  sessionId?: string; // Current RegisterSession ID
  transactionNumber: string; // Human-readable, sequential per register/session or per tenant
  items: SaleItem[];
  subTotal: number; // Sum of (item.quantity * item.unitPrice) across all items
  totalDiscountAmount?: number; // Sum of item discounts + transaction-level discounts
  totalTaxAmount?: number; // Sum of item taxes + transaction-level taxes
  grandTotal: number; // subTotal - totalDiscountAmount + totalTaxAmount
  payments: PaymentDetail[]; // Array of payments made for this sale
  amountTendered: number; // Total amount given by customer across all payments
  changeGiven: number;
  customerId?: string; // From CRM or local customer data
  cashierId: string; // User ID from user-service who processed the sale
  transactionTimestamp: Date; // Exact time of completion
  status: SaleStatus;
  isOfflineTransaction?: boolean; // If created offline and synced later
  offlineTransactionId?: string; // Original local ID if this is a synced transaction
  voidedByUserId?: string;
  voidReason?: string;
  linkedReturnSaleId?: string; // If this is a sale part of an exchange or linked to a return
  notes?: string;
  // Receipt data can be derived or a snapshot stored if it's highly dynamic/templated at point of sale
  // receiptNumber?: string;
  createdAt: Date;
  updatedAt: Date;
}

export interface RegisterSession {
  id: string; // UUID
  tenantId: string;
  registerId: string; // ID of the physical POS device/terminal
  cashierId: string; // User ID of the person who opened/is responsible for the session
  openingTimestamp: Date;
  closingTimestamp?: Date;
  openingFloatAmount: number; // Cash amount at the start of the session
  closingFloatAmount?: number; // Expected cash amount at end (calculated from sales and opening float)
  actualCashAtClose?: number; // Actual counted cash amount
  discrepancyAmount?: number; // Difference between expected and actual
  // Summaries of sales, payments by type would be calculated and potentially stored here
  totalSalesAmount?: number;
  totalReturnsAmount?: number;
  paymentsByTypeSummary?: Record<PaymentType, { count: number; totalAmount: number }>;
  status: 'open' | 'closed' | 'reconciled' | 'discrepancy';
  notes?: string; // For any notes during open/close or reconciliation
  closedByUserId?: string;
  reconciledByUserId?: string;
  reconciliationTimestamp?: Date;
}

// Simplified for offline needs - these would be populated from other services during online sync
export interface OfflineProduct {
  itemId: string; // Match ID from inventory-service
  sku: string;
  name: string;
  unitPrice: number;
  taxRate?: number; // Or tax category ID
  category?: string;
  allowPriceOverride?: boolean;
  isWeightedItem?: boolean;
}
export interface OfflineCustomer {
  id: string; // Match ID from crm-service
  name: string;
  loyaltyPoints?: number;
  customerGroup?: string; // For specific discounts/pricing
  canPurchaseOnAccount?: boolean;
  creditLimit?: number;
}
export interface OfflinePromotion {
    promoId: string;
    name: string;
    appliesToItemIds?: string[];
    appliesToCategories?: string[];
    discountType: 'percentage' | 'fixed_amount';
    discountValue: number;
    // conditions, start/end dates etc.
}
